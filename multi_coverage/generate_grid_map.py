import numpy as np
from scipy import ndimage
from cluster_centroid import in_hull_cvx, pixel_centroid
import matplotlib.pyplot as plt


class MapGenerate():
    def __init__(self, boxVert=None, ws=None, xy_res=0.5, z_res=0.5, margin=0.1):
        self.boundary = ws
        self.boxVert = boxVert

        self.xy_res = xy_res
        self.z_res = z_res
        self.margin = margin
        self.nx = int(np.ceil(np.abs(ws[0, 1] - ws[0, 0]) / self.xy_res))
        self.ny = int(np.ceil(np.abs(ws[1, 1] - ws[1, 0]) / self.xy_res))
        self.nz = int(np.ceil(np.abs(ws[2, 1] - ws[2, 0]) / self.z_res))
        self.sz = np.array([self.nx, self.ny, self.nz])

        self.nSub = 3

        all_inds = np.unravel_index(range(0, self.nx*self.ny*self.nz),self.sz,order="F")
        ijk = np.array(all_inds).T
        self.all_pt = self.idx_to_points(ijk)

        # generate occ map with obs
        occ_map_obs = np.zeros((self.nx, self.ny, self.nz), dtype=bool)
        occ_map_obs_ravel = occ_map_obs.reshape((np.array(occ_map_obs).size, 1), order="F")
        for iBox in range(0, boxVert.shape[1]):
            obs_free_ind = in_hull_cvx(self.all_pt, boxVert[0,iBox].T)
            occ_map_obs_ravel[obs_free_ind == 1] = 1
        occ_map_obs = occ_map_obs_ravel.reshape(np.array([self.nx, self.ny, self.nz]), order="F")
        self.occ_map_obs = occ_map_obs

        # generate obs free pt 
        obs_free = np.where(occ_map_obs==0)
        self.obs_free_pt = self.idx_to_points(np.array(obs_free).T)

        # ax = plt.axes(projection='3d')
        # ax.scatter3D(self.obs_free_pt[:,0], self.obs_free_pt[:,1], self.obs_free_pt[:,2],cmap='Greens')
        # plt.show()
        
        # generate occ map without obs
        occ_map = np.zeros((self.nx, self.ny, self.nz), dtype=bool)
        occ_map_ravel = occ_map.reshape((np.array(occ_map).size, 1), order="F")
        box_free_ind = in_hull_cvx(self.all_pt, boxVert[0,0].T)
        occ_map_ravel[box_free_ind == 1] = 1
        occ_map = occ_map_ravel.reshape(np.array([self.nx, self.ny, self.nz]), order="F")
        self.occ_map = occ_map
        self.occ_map_2d = occ_map[:, :, 0]

        bw_2d = ~occ_map[:, :, 0]
        bw_3d = ~occ_map
        self.emap_2d = ndimage.distance_transform_edt(bw_2d) * xy_res
        self.emap_3d = ndimage.distance_transform_edt(bw_3d) * xy_res

        
        density_map = -self.emap_3d + self.emap_3d.max()*np.ones((self.nx,self.ny,self.nz))
        self.density_map = pow(density_map,2)
        # self.density_map = np.exp(density_map)
        # self.density_map = np.exp(pow(density_map,2))

        fig, (ax1, ax2) = plt.subplots(1,2)
        fig.suptitle('Denisty map')
        ax1.matshow(self.density_map[:,:,0])
        ax2.imshow(~self.occ_map_obs[:,:,0], cmap='binary')

        # fig_root = './log/binary.png'
        # if not os.path.exists(fig_root):
        #     os.mknod(fig_root)
        # fig.savefig(fig_root)

        plt.matshow(self.density_map[:,:,0])
        # fig_root2 = './log/density.png'
        # if not os.path.exists(fig_root2):
        #     os.mknod(fig_root)
        # plt.savefig(fig_root2)

        plt.colorbar()
        plt.show()

        ## cloudpoint NEED TO DO
        # obs = np.where(self.emap_3d == 0)
        # obs_pt = self.idx_to_points(obs)
        # self.ptCloud = pointCloud(obs_pt)

        print('map gen')

    def points_to_idx(self, xyz=None):
        # convert 3d points xyz (Nx3) into indices in occupancy grid
        # @input:   self         self generated by load_map
        #           xyz         Nx3 3d points in actual space
        # @output:  ijk         Nx3 indices in self's occupancy grid
        ijk = np.ones((xyz.shape[0], 3), dtype=int)
        if xyz.shape[0] > 0:
            ijk[:, 0] = min(max(int(np.floor((xyz[:, 0] - self.boundary[0, 0]) / self.xy_res + 1)), 1), self.nx)
            ijk[:, 1] = min(max(int(np.floor((xyz[:, 1] - self.boundary[1, 0]) / self.xy_res + 1)), 1), self.ny)
            ijk[:, 2] = min(max(int(np.floor((xyz[:, 2] - self.boundary[2, 0]) / self.z_res + 1)), 1), self.nz)
        else:
            raise Exception('Wrong!')

        return ijk

    def idx_to_points(self, ijk=None):
        # convert indices in occupancy grid into 3d points xyz (Nx3)
        # @input:   self         self generated by load_map
        #           ijk         Nx3 indices in self's occupancy grid
        # @output:  xyz         Nx3 3d points in actual space
        xyz = np.ones((ijk.shape[0], 3))
        if ijk.shape[0] > 0:
            xyz[:, 0] = self.boundary[0, 0] + ijk[:, 0] * self.xy_res + self.xy_res * 0.5
            xyz[:, 1] = self.boundary[1, 0] + ijk[:, 1] * self.xy_res + self.xy_res * 0.5
            xyz[:, 2] = self.boundary[2, 0] + ijk[:, 2] * self.z_res + self.z_res * 0.5
        else:
            raise Exception('Wrong!')

        return xyz